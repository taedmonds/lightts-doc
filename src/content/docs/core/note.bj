**"Core"**

This single-word name is concise, reflects that response and error handling classes (`HttpResponse`, `DataResponse`, `MessageResponse`, `HttpError`, `ConflictError`, `BadRequestError`, etc.) are built-in tools included with every LightTs project via `lts init`, and is flexible for future core utilities (e.g., pagination, logging). It aligns with LightTs’s focus on simplicity and native Node.js functionality, similar to a "toolkit" but distinct.

### Revised Files with Section Name "Core"
Below are the updated `src/content/docs/core/` files (`overview.mdx`, `responses.mdx`, `errors.mdx`), emphasizing that these classes are built-in tools included with `lts init`, like other core utilities (e.g., CORS, logger). Examples are simple, excluding validation or authentication middleware, and align with the provided project structure and naming conventions (kebab-case for files/folders, camelCase for functions/variables). The files use `starlight-theme-rapide` components (`<Tabs>`, `<TabItem>`, `<Steps>`, `<LinkCard>`, `<FileTree>`), avoid `<CardGrid>`, and use `<div class="card-container">` with flexbox from `custom.css` to prevent framing issues. The content maintains the dark theme with purple accents (`#7c3aed`), a conversational tone, and concise text to align with LightTs’s lightweight, customizable, and community-driven identity, avoiding a "research paper with bloated text" feel. The controller (Express `Router`) and service (default export object) patterns from your `user.controller.ts` and `user.service.ts` are used in simplified examples.

### `src/styles/custom.css` (Reference)
The `custom.css` remains as provided:

```css
.card-container {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  justify-content: center;
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
}

.card-container > * {
  flex: 1 1 300px;
  max-width: 400px;
}
```

### `src/content/docs/core/overview.mdx`
Introduces the Core section, emphasizing that response and error handling classes are built-in tools included with `lts init`, and links to `responses.mdx` and `errors.mdx`.

```mdx

```mdx
---
title: Core Overview
description: Learn about LightTs's built-in response and error handling tools.
---

import { Card, LinkCard, FileTree } from '@astrojs/starlight/components';

```
   .-+*+-.   Core
  :       :  Built-in API Tools
 :_______:  Clean and Consistent
```

# Core Overview

LightTs includes **built-in response and error handling classes** as part of every project initialized with `lts init`. These core tools, built with native Node.js and Express, standardize API responses and errors, keeping your code clean and aligned with LightTs’s simplicity, like other utilities such as CORS and logging.

## Included Files

These classes are included in `src/core/` when you create a LightTs project, using kebab-case for file names:

<FileTree>
- src/
  - core/
    - responses/
      - data.response.ts
      - message.response.ts
      - index.ts
    - errors/
      - bad-request.error.ts
      - conflict.error.ts
      - forbidden.error.ts
      - handler.error.ts
      - index.ts
      - not-found.error.ts
      - server-error.error.ts
      - unauthorized.error.ts
</FileTree>

## Available Tools

<div class="card-container">
  <Card title="Response Classes" icon="seti:typescript">
    Use `HttpResponse`, `DataResponse`, and `MessageResponse` for consistent API success responses.

    <LinkCard title="Explore Response Classes" href="/core/responses/" description="Standardize success responses with built-in classes." />
  </Card>
  <Card title="Error Classes" icon="seti:typescript">
    Use `HttpError` and specific error classes like `ConflictError` for robust error handling.

    <LinkCard title="Explore Error Classes" href="/core/errors/" description="Handle errors with built-in classes and middleware." />
  </Card>
</div>
```

```

### `src/content/docs/core/responses.mdx`
Documents the response classes (`HttpResponse`, `DataResponse`, `MessageResponse`) as built-in tools with simple examples.

```mdx

```mdx
---
title: Response Classes
description: Learn how to use LightTs's built-in response classes.
---

import { Tabs, TabItem, Steps, LinkCard, FileTree } from '@astrojs/starlight/components';

```
   .-+*+-.   Response Classes
  :       :  Consistent API Responses
 :_______:  LightTs Core
```

# Response Classes

LightTs provides built-in `HttpResponse`, `DataResponse`, and `MessageResponse` classes to standardize API success responses. Included with `lts init`, these core tools ensure clean, consistent output using native Node.js and Express, keeping your API lightweight.

## Using Response Classes

<Steps>
1. **Locate Classes**

   Find the response classes in `src/core/responses/`, included with every LightTs project.

2. **Use in Services**

   Integrate response classes in your services for consistent API output.
</Steps>

### Included Files

The response classes are in `src/core/responses/`, using kebab-case for file names:

<FileTree>
- src/
  - core/
    - responses/
      - data.response.ts
      - message.response.ts
      - index.ts
</FileTree>

## Response Classes

These classes use camelCase for methods and variables, providing flexible response formatting.

<Tabs>
  <TabItem label="HttpResponse">
    ```typescript
    // src/core/responses/index.ts
    import { Response } from 'express';

    export class HttpResponse {
      public readonly statusCode: number;
      public readonly message: string | undefined;
      public readonly data: any;
      public readonly meta?: any;

      constructor(
        res: Response,
        {
          statusCode = 200,
          message,
          data = null,
          meta
        }: {
          statusCode?: number;
          message?: string;
          data?: any;
          meta?: any;
        }
      ) {
        this.statusCode = statusCode;
        this.message = message;
        this.data = data;
        this.meta = meta;

        let options = {};

        options['statusCode'] = this.statusCode;
        if (this.message) options['message'] = this.message;
        if (this.data) options['data'] = this.data;
        if (this.meta) options['meta'] = this.meta;

        res.status(statusCode).json(options);
      }
    }
    ```
  </TabItem>
  <TabItem label="DataResponse">
    ```typescript
    // src/core/responses/data.response.ts
    import { Response } from 'express';
    import { HttpResponse } from '.';

    export class DataResponse extends HttpResponse {
      constructor(
        res: Response,
        {
          data,
          message = 'data retrieved',
          statusCode = 200,
          meta
        }: {
          data: any;
          message?: string;
          statusCode?: number;
          meta?: any;
        }
      ) {
        super(res, { statusCode, message, data, meta });
      }
    }
    ```
  </TabItem>
  <TabItem label="MessageResponse">
    ```typescript
    // src/core/responses/message.response.ts
    import { Response } from 'express';
    import { HttpResponse } from '.';

    export class MessageResponse extends HttpResponse {
      constructor(
        res: Response,
        {
          message = 'success',
          statusCode = 200,
          meta
        }: {
          message?: string;
          statusCode?: number;
          meta?: any;
        }
      ) {
        super(res, { statusCode, message, data: null, meta });
      }
    }
    ```
  </TabItem>
</Tabs>

## Example Usage

Use `DataResponse` for data-heavy responses and `MessageResponse` for simple success messages, paired with a minimal controller.

<Tabs>
  <TabItem label="Service">
    ```typescript
    // src/modules/user/user.service.ts
    import { DataResponse } from '@/core/responses/data.response';
    import { MessageResponse } from '@/core/responses/message.response';
    import { Request, Response } from 'express';

    export default {
      getUsers: async (req: Request, res: Response) => {
        const userData = [{ id: 1, name: 'John Doe' }];
        return new DataResponse(res, {
          data: userData,
          message: 'Users fetched!',
          statusCode: 200,
        });
      },
      createUser: async (req: Request, res: Response) => {
        return new MessageResponse(res, { message: 'User created!', statusCode: 201 });
      },
    };
    ```
  </TabItem>
  <TabItem label="Controller">
    ```typescript
    // src/modules/user/user.controller.ts
    import express from 'express';
    import services from './user.service';

    const router = express.Router();

    router.get('/', services.getUsers);
    router.post('/', services.createUser);

    export default router;
    ```
  </TabItem>
</Tabs>

## Notes

- **Customization**: Extend `HttpResponse` in `src/core/responses/` for custom response types.
- **Naming Conventions**: Files use kebab-case (e.g., `data.response.ts`), classes and methods use camelCase (e.g., `DataResponse`, `getUsers`).
- **Usage**: Use `DataResponse` for endpoints with data, `MessageResponse` for simple confirmations.

<LinkCard title="See Responses in Action" href="/examples/user-management/" description="Try a user management API with standardized responses." />
```

```

### `src/content/docs/core/errors.mdx`
Documents the error classes (`HttpError`, `ConflictError`, `BadRequestError`) as built-in tools with simple examples and middleware setup.

---
title: Error Classes
description: Learn how to use LightTs's built-in error classes and middleware.
---

import { Tabs, TabItem, Steps, LinkCard, FileTree } from '@astrojs/starlight/components';

```
   .-+*+-.   Error Classes
  :       :  Robust Error Handling
 :_______:  LightTs Core
```

# Error Classes

LightTs provides built-in `HttpError` and specific error classes like `ConflictError` and `BadRequestError` to standardize error handling. Included with `lts init`, these core tools and a middleware handler ensure consistent error responses using native Node.js and Express.

## Using Error Classes

<Steps>
1. **Locate Classes**

   Find the error classes in `src/core/errors/`, included with every LightTs project.

2. **Set Up Middleware**

   Add `HttpError.middleware` to `src/index.ts` to catch errors.
</Steps>

### Included Files

The error classes are in `src/core/errors/`, using kebab-case for file names:

<FileTree>
- src/
  - core/
    - errors/
      - bad-request.error.ts
      - conflict.error.ts
      - forbidden.error.ts
      - handler.error.ts
      - index.ts
      - not-found.error.ts
      - server-error.error.ts
      - unauthorized.error.ts
</FileTree>

## Error Classes

These classes use camelCase for methods and variables, supporting common HTTP errors.

<Tabs>
  <TabItem label="HttpError">
    ```typescript
    // src/core/errors/index.ts
    import { Request, Response } from 'express';

    export class HttpError extends Error {
      public readonly statusCode: number;
      public readonly details?: any;

      constructor(statusCode: number, message: string, details?: any) {
        super(message);
        this.statusCode = statusCode;
        this.details = details;
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }

      static middleware(err: any, req: Request, res: Response) {
        const statusCode = err.statusCode || 500;

        res.status(statusCode).json({
          success: false,
          message: err.message || 'internal server error'
        });
      }
    }
    ```
  </TabItem>
  <TabItem label="ConflictError">
    ```typescript
    // src/core/errors/conflict.error.ts
    import { HttpError } from '.';

    export class ConflictError extends HttpError {
      constructor(message: string = 'conflict', details?: any) {
        super(409, message, details);
      }
    }
    ```
  </TabItem>
  <TabItem label="BadRequestError">
    ```typescript
    // src/core/errors/bad-request.error.ts
    import { HttpError } from '.';

    export class BadRequestError extends HttpError {
      constructor(message: string = 'bad request', details?: any) {
        super(400, message, details);
      }
    }
    ```
  </TabItem>
</Tabs>

## Setup Error Middleware

Add the error middleware to your application:

```typescript
// src/index.ts
import express from 'express';
import { HttpError } from '@/core/errors';
import routes from './routes';
import { corsMiddleware } from '@/core/cors.core';
import { log } from '@/core/logger.core';

const app = express();
app.use(corsMiddleware);
app.use(express.json());
app.use('/api', routes);

// Error middleware
app.use(HttpError.middleware);

app.listen(3000, () => log.info('Server running on http://localhost:3000'));
```

## Example Usage

Throw error classes in your services, paired with a minimal controller.

<Tabs>
  <TabItem label="Service">
    ```typescript
    // src/modules/user/user.service.ts
    import { BadRequestError } from '@/core/errors/bad-request.error';
    import { ConflictError } from '@/core/errors/conflict.error';
    import { DataResponse } from '@/core/responses/data.response';
    import { MessageResponse } from '@/core/responses/message.response';
    import { Request, Response } from 'express';

    export default {
      getUsers: async (req: Request, res: Response) => {
        const userData = [{ id: 1, name: 'John Doe' }];
        return new DataResponse(res, {
          data: userData,
          message: 'Users fetched!',
          statusCode: 200,
        });
      },
      createUser: async (req: Request, res: Response) => {
        const { email } = req.body;
        if (!email) throw new BadRequestError('Email is required!');
        if (email === 'existing@example.com') throw new ConflictError('Email already exists!');
        return new MessageResponse(res, { message: 'User created!', statusCode: 201 });
      },
    };
    ```
  </TabItem>
  <TabItem label="Controller">
    ```typescript
    // src/modules/user/user.controller.ts
    import express from 'express';
    import services from './user.service';

    const router = express.Router();

    router.get('/', services.getUsers);
    router.post('/', services.createUser);

    export default router;
    ```
  </TabItem>
</Tabs>

## Notes

- **Customization**: Extend `HttpError` in `src/core/errors/` for custom error types.
- **Naming Conventions**: Files use kebab-case (e.g., `conflict.error.ts`), classes and methods use camelCase (e.g., `ConflictError`, `throwError`).
- **Error Handling**: Place `HttpError.middleware` last in `src/index.ts` to catch all errors.
- **Available Errors**: Includes `BadRequestError` (400), `ConflictError` (409), `ForbiddenError` (403), `NotFoundError` (404), `UnauthorizedError` (401), and `ServerError` (500).

<LinkCard title="See Errors in Action" href="/examples/user-management/" description="Try a user management API with standardized error handling." />
